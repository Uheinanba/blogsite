(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{63:function(e,t,a){"use strict";a.r(t);var n=a(0),r=Object(n.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",{staticClass:"content"},[a("h1",{attrs:{id:"babel-插件手册"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#babel-插件手册","aria-hidden":"true"}},[e._v("#")]),e._v(" Babel 插件手册")]),a("h3",{attrs:{id:"babel-工作原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#babel-工作原理","aria-hidden":"true"}},[e._v("#")]),e._v(" babel 工作原理")]),a("pre",[a("code",[e._v("   Parse         Transform          Generator\n")])]),a("p",[e._v("code --------\x3e AST ------------\x3e  AST --------------\x3e  code\nbabylon      babel-traverse     babel-generator")]),a("h3",{attrs:{id:"基础"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基础","aria-hidden":"true"}},[e._v("#")]),e._v(" 基础")]),a("p",[e._v("Babel是javascript编译器,更确切的说是源码到源码的编译器，通常称为“转换编译器(transpiler)”意思是说你为Babel提供一些JavaScript代码，Babel更改这些代码，然后返回给你新的代码。")]),a("h4",{attrs:{id:"asts"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#asts","aria-hidden":"true"}},[e._v("#")]),e._v(" ASTs")]),a("p",[e._v("使用"),a("a",{attrs:{href:"http://astexplorer.net",target:"_blank",rel:"noopener noreferrer"}},[e._v("AST Explorer")]),e._v("可以对AST节点有更感性的认识。")]),a("p",[e._v("比如:")]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function square(n) {\n  return n * n;\n}\n")])]),a("p",[e._v("AST 的每层结构相同:")]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('{\n  type: "FunctionDeclaration",\n  id: {...},\n  params: [...],\n  body: {...}\n}\n')])]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('{\n  type: "Identifier",\n  name: ...\n}\n')])]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('{\n  type: "BinaryExpression",\n  operator: ...,\n  left: {...},\n  right: {...}\n}\n')])]),a("p",[e._v("这样的每层结构称为节点(Node),一个AST可以由单一节点或者成百上千节点构成。他们组合在一起可以描述用于静态分析的程序语法。\n可以描述为")]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("interface Node {\n  type: string; // 'FunctionDeclaration', 'Identifier', 'BinaryExpression'\n}\n")])]),a("h4",{attrs:{id:"visitor"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#visitor","aria-hidden":"true"}},[e._v("#")]),e._v(" Visitor")]),a("p",[e._v("Visitor是一个用于AST遍历跨语言的模式，简单的来讲它们就是一个对象，定义了用于在一个树状结构中获取具体节点的方法。")]),a("p",[e._v("比如:我只是想访问if...else生成的节点，我们可以在visitor里指定获取它所对应的节点")]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const visitor = {\n    IFStatement() {\n        console.log('get if');\n    }\n}\n")])]),a("p",[e._v("其实上述遍历会让每个节点被访问两次，一次是向下遍历代表进入(enter),一次是向上退出(exit)。因此实际上每个节点都会有enter和exit方法，在实际操作的时候需要注意这种遍历方式可能会引起一些问题。 上面例子是忽略掉enter的简写")]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const visitor = {\n    IfStatement: {\n        enter() {},\n        exit() {}\n    }\n}\n")])]),a("h4",{attrs:{id:"path"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#path","aria-hidden":"true"}},[e._v("#")]),e._v(" Path")]),a("p",[e._v("AST 通常会有很多节点，那么节点直接如何相互关联呢。我们可以使用Path简化这件事。\nPath 是一个对象，它表示两个节点之间的连接。通过这个对象我们可以访问到节点，父节点以及进行一系列节点操作相关的方法(类似DOM操作)。")]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const MyVisitor = {\n    Identifier(path) {\n        console.log('visiting:' + path.node.name);\n    }\n}\n")])]),a("h3",{attrs:{id:"api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#api","aria-hidden":"true"}},[e._v("#")]),e._v(" API")]),a("p",[e._v("babel实际上是一组模块的集合.")]),a("h4",{attrs:{id:"babylon"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#babylon","aria-hidden":"true"}},[e._v("#")]),e._v(" babylon")]),a("ol",[a("li",[e._v("基本使用")])]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('import babylon from "babylon";\nconst code = `function square(n) {\n    return n * n;\n}`;\nbabylon.parse(code);\n')])]),a("ol",{attrs:{start:"2"}},[a("li",[e._v("parse方法还能够传递选项")])]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("babylon.parse(code, {\n    sourceType: 'module',\n    plugins: ['jsx']\n});\n")])]),a("p",[e._v("sourceType可以是'module'或者是'script'它表示babylon应该用哪种模式来解析。'module'将会在严格模式下解析并允许模块定义。\"script\"则不会。")]),a("h4",{attrs:{id:"babel-traverse"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#babel-traverse","aria-hidden":"true"}},[e._v("#")]),e._v(" babel-traverse")]),a("p",[e._v("babel Traverse模块维护了整棵树的状态，并且负责替换，移除和添加节点。\n我们可以和Babylon一起来遍历和更新节点:")]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var babel = require('babel-core');\nconst babylon = require('babylon');\nconst traverse = require('babel-traverse').default;\nconst generator = require('babel-generator').default;\n\nconst code = `\nfunction square(n) {\n    return n * n;\n}`;\n\nconst ast = babylon.parse(code, {\n    sourceType: \"module\"\n});\n\ntraverse(ast, {\n    enter(path) {\n        if(\n            path.node.type === 'Identifier' &&\n            path.node.name === 'n'\n        ) {\n            path.node.name = 'x';\n        }\n    }\n})\n\nconsole.log(generator(ast).code);\n")])]),a("h4",{attrs:{id:"babel-types"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#babel-types","aria-hidden":"true"}},[e._v("#")]),e._v(" babel-types")]),a("p",[e._v("Babel Types模块是一个用于ast节点的Lodash式的工具库,它包含构造，验证以及变换ast节点的方法。该工具库包含考虑周到的工具方法，对编写处理ast处理逻辑非常有用。")]),a("ol",[a("li",[e._v("示例")])]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('import traverse from "babel-traverse";\nimport t from "babel-types";\n\ntraverse(ast, {\n  enter(path) {\n    if (t.isIdentifier(path.node, { name: "n" })) {\n      path.node.name = "x";\n    }\n  }\n});\n')])]),a("ol",{attrs:{start:"2"}},[a("li",[e._v("Definitions(定义)\nBabel Types模块拥有每一个单一类型节点的定义, 包括节点包括哪些属性，什么合法值，如何构建节点遍历节点，以及节点的别名等信息。\n单一节点类型的定义形式如下:")])]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('defineType("BinaryExpression", {\n  builder: ["operator", "left", "right"],\n  fields: {\n    operator: {\n      validate: assertValueType("string")\n    },\n    left: {\n      validate: assertNodeType("Expression")\n    },\n    right: {\n      validate: assertNodeType("Expression")\n    }\n  },\n  visitor: ["left", "right"],\n  aliases: ["Binary", "Expression"]\n});\n')])]),a("ol",{attrs:{start:"3"}},[a("li",[e._v("Builders(构建器)\n上面的BinaryExpression 定义有一个builder字段。")])]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("builder: ['operator', 'left', 'right']\n")])]),a("p",[e._v("这是由于每一个节点类型都有构造器方法builder。按照类似下面方式使用")]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('t.binaryExpression(\'*\', t.identifier("a"), t.identifier("b"));\n')])]),a("p",[e._v("可以创建如下的AST:")]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('{\n  type: "BinaryExpression",\n  operator: "*",\n  left: {\n    type: "Identifier",\n    name: "a"\n  },\n  right: {\n    type: "Identifier",\n    name: "b"\n  }\n}\n')])]),a("ol",{attrs:{start:"4"}},[a("li",[e._v("Validators(验证器)\nBinaryExpression的定义还包含了节点的字段fields信息，以及如何验证这些字段")])]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('fields: {\n  operator: {\n    validate: assertValueType("string")\n  },\n  left: {\n    validate: assertNodeType("Expression")\n  },\n  right: {\n    validate: assertNodeType("Expression")\n  }\n}\n')])]),a("ul",[a("li",[e._v("可以创建两种验证方法，第一种是JSX")])]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("t.isBinaryExpression(maybeBinaryExpressionNode)\n")])]),a("ul",[a("li",[e._v("同时可以传入第二个参数来确保节点包含特定的属性和值。")])]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('t.isBinaryExpression(maybeBinaryExpressionNode, { operator: "*" });\n')])]),a("h4",{attrs:{id:"babel-generator"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#babel-generator","aria-hidden":"true"}},[e._v("#")]),e._v(" babel-generator")]),a("p",[e._v("Babel Generator 模块是Babel代码生成器,它读取AST并将转换成代码和源码映射。")]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('import * as babylon from "babylon";\nimport generate from "babel-generator";\n\nconst code = `function square(n) {\n  return n * n;\n}`;\n\nconst ast = babylon.parse(code);\n\ngenerate(ast, {}, code);\n')])]),a("h4",{attrs:{id:"babel-template"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#babel-template","aria-hidden":"true"}},[e._v("#")]),e._v(" babel-template")]),a("p",[e._v("babel-template 是另外一个虽然很小但是非常有用的模块。它能让你编写字符串形式并且带有占位符的代码来代替手动编码, 尤其是生成的大规模AST时候。")]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('import template from "babel-template";\nimport generate from "babel-generator";\nimport * as t from "babel-types";\n\nconst buildRequire = template(`\n  var IMPORT_NAME = require(SOURCE);\n`);\n\nconst ast = buildRequire({\n  IMPORT_NAME: t.identifier("myModule"),\n  SOURCE: t.stringLiteral("my-module")\n});\n\nconsole.log(generate(ast).code);\n// var myModule = require("my-module");\n')])]),a("h3",{attrs:{id:"babel插件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#babel插件","aria-hidden":"true"}},[e._v("#")]),e._v(" Babel插件")]),a("p",[e._v("// http://web.jobbole.com/91277/\n1.")]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const code = `abs(-8);`;\n\nconst visitor = {\n\tCallExpression(path) {\n\t\tif (path.node.callee.name !== 'abs') return;\n\n\t\tpath.replaceWith(t.CallExpression(\n\t\t\tt.MemberExpression(t.identifier('Math'), t.identifier('abs')),\n\t\t\tpath.node.arguments\n\t\t));\n\t}\n};\n\nconst result = babel.transform(code, {\n\tplugins: [{\n\t\tvisitor: visitor\n\t}]\n});\n\n// Math.abs(-8)\nconsole.log(result.code);\n")])]),a("ol",{attrs:{start:"2"}},[a("li")]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function MyVisitor({ types: t }) {\n    return {\n      visitor: {\n        BinaryExpression(path) {\n            if (path.node.operator !== \"===\") {\n                return;\n            }\n            const left = path.get('left');\n            const right = path.get('right');\n            path.node.left = t.identifier(\"sebmck\");\n        }\n      }\n    };\n}\nconst code = 'foo === bar';\nconst ast = babel.transform(code, {plugins: [MyVisitor]});\nconsole.log(ast.code);\n")])]),a("h3",{attrs:{id:"转换操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#转换操作","aria-hidden":"true"}},[e._v("#")]),e._v(" 转换操作")]),a("h4",{attrs:{id:"访问"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#访问","aria-hidden":"true"}},[e._v("#")]),e._v(" 访问")]),a("ol",[a("li",[e._v("获取子节点的path\n为了得到一个AST节点的属性值, 我们一般先访问到该节点，然后利用path.node.property方法即可。")])]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("BinaryExpression(path) {\n    path.node.left,\n    path.node.operator\n}\n")])]),a("ol",{attrs:{start:"2"}},[a("li",[e._v("检查子节点的类型")])]),a("ul",[a("li",[e._v("最好的方式是")])]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("BinaryExpression(path) {\n    if (t.isIdentifier(path.node.left)) {\n        // ..\n    }\n}\n")])]),a("ul",[a("li",[e._v("同样可以对节点的属性们做浅层的检查")])]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("BinaryExpression(path) {\n    if (t.isIdentifier(path.node.left, {name: 'n'})) {\n        // ..\n    }\n}\n\n")])]),a("p",[e._v("等价于:")]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('BinaryExpression(path) {\n  if (\n    path.node.left != null &&\n    path.node.left.type === "Identifier" &&\n    path.node.left.name === "n"\n  ) {\n    // ...\n  }\n}\n')])]),a("ol",{attrs:{start:"3"}},[a("li",[e._v("检查路径(Path)类型\n一个路径具有相同的方法检查节点的类型:")])]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("BinaryExpression(path) {\n    if (path.get('left').isIdentifier({name: 'n'})) {\n        // ..\n    }\n}\n")])]),a("p",[e._v("相当于:")]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("BinaryExpression(path) {\n    if (t.isIdentifier(path.node.left, {name: 'n'})) {\n        // ...\n    }\n}\n")])]),a("ol",{attrs:{start:"3"}},[a("li",[e._v("检查标识符(Identifier)是否被引用")])]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Identifier(path) {\n  if(path.isReferencedIdentifier()) { // 等价于 t.isReferenced(path.node, path.parent)\n    // ...\n  }\n}\n")])]),a("ol",{attrs:{start:"4"}},[a("li",[e._v("找到特定的父路径")])]),a("ul",[a("li",[e._v("从一个路径向上遍历语法树，直到满足相应条件")])]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("path.findParent(path => path.isObjectExpression());\n")])]),a("ul",[a("li",[e._v("遍历当前节点")])]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("path.find(path => path.isObjectExpression())\n")])]),a("ul",[a("li",[e._v("查找最接近的父函数或程序")])]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("path.getFunctionParent()\n")])]),a("ul",[a("li",[e._v("向上遍历语法树，直到找到在列表中的父节点路径")])]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("path.getStatementParent()\n")])]),a("ol",{attrs:{start:"5"}},[a("li",[e._v("获取同级路径")])])])}],!1,null,null,null);t.default=r.exports}}]);